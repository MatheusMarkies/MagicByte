#pragma kernel CSMain

RWTexture2D<float4> Result;

#define PI 3.14159265359
#define EPSILON 1e-8

int _SceneObjectsCount;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;

int _Indexes;

Texture2D <float4> _SkyboxTexture;
SamplerState sampler_SkyboxTexture;

int _rayMaxHits = 6;

float3 _LightColor;
float _LightIntensity;

float4 _DirectionalLight;
float4 _DirectionalLightDirection;
float3 _WorldSpaceCameraPos;

struct sceneObject {
    float4 Position;
    float4 Albedo;
    float Smoothness;
    float Metallic;
    float4 Emission;
    float Anisotropy;
    int RenderType;

    int ObjectMesh;

    int indices_offset;
    int indices_count;
    float4x4 localToWorldMatrix;
};

StructuredBuffer<sceneObject> _Objects;
StructuredBuffer<float3> _Vertices;
StructuredBuffer<int> _Indices;

struct CameraRay {
    float3 raySource;
    float3 rayDirection;
    float3 rayColor;
};

CameraRay CreateRay(float3 source, float3 direction)
{
    CameraRay ray;
    ray.raySource = source;
    ray.rayDirection = direction;
    ray.rayColor = float3(_LightColor.r * _LightIntensity, _LightColor.g * _LightIntensity, _LightColor.b * _LightIntensity);

    return ray;
}

CameraRay CreateCameraRay(float2 uv)
{
    float3 source = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;

    float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);
    return CreateRay(source, direction);
}

struct CameraRayHit
{
    float3 rayHitPosition;
    float rayHitDistance;
    float3 rayHitNormal;

    float3 viewDirection;
    float4 lightDirection;

    float3 rayHitAlbedo;
    float3 rayHitEmission;
    float rayHitSmoothness;
    float rayHitMetallic;
    float rayHitAnisotropy;

    int hitRenderType;
};

CameraRayHit CreateRayHit()
{
    CameraRayHit hit;
    hit.rayHitPosition = float3(0.0f, 0.0f, 0.0f);
    hit.rayHitDistance = 1.#INF;
    hit.rayHitNormal = float3(0.0f, 0.0f, 0.0f);

    hit.viewDirection = _WorldSpaceCameraPos;
    hit.lightDirection = _DirectionalLightDirection;

    hit.rayHitAlbedo = pow(float3(0.0f, 0.0f, 0.0f),2.2);
    hit.rayHitEmission = float3(0.5f, 0.5f, 0.5f);
    hit.rayHitAnisotropy = 0;

    hit.rayHitSmoothness = 0;
    hit.rayHitMetallic = 0;

    hit.hitRenderType = 0;

    return hit;
}

/*
http://www.graphics.cornell.edu/pubs/1997/MT97.html
https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/barycentric-coordinates
*/
bool IntersectTriangle(CameraRay ray, float3 vert0, float3 vert1, float3 vert2,inout float t, inout float u, inout float v)
{
    float3 edge1 = vert1 - vert0;
    float3 edge2 = vert2 - vert0;
    float3 pvec = cross(ray.rayDirection, edge2);
    float det = dot(edge1, pvec);
    if (det < EPSILON)
        return false;
    float inv_det = 1.0f / det;
    float3 tvec = ray.raySource - vert0;
    u = dot(tvec, pvec) * inv_det;
    if (u < 0.0 || u > 1.0f)
        return false;
    float3 qvec = cross(tvec, edge1);
    v = dot(ray.rayDirection, qvec) * inv_det;
    if (v < 0.0 || u + v > 1.0f)
        return false;
    t = dot(edge2, qvec) * inv_det;
    return true;
}

void IntersectMeshObject(int index, CameraRay ray, inout CameraRayHit bestHit)
{
    int offset = _Objects[index].indices_offset;
    int count = offset + 1024;
    //int count = offset + _Objects[index].indices_count;

    for (uint i = offset; i < count; i += 3)
    {
       float3 v0 = (mul(_Objects[index].localToWorldMatrix, float4(_Vertices[_Indices[i]], 1))).xyz;
       float3 v1 = (mul(_Objects[index].localToWorldMatrix, float4(_Vertices[_Indices[i + 1]], 1))).xyz;
       float3 v2 = (mul(_Objects[index].localToWorldMatrix, float4(_Vertices[_Indices[i + 2]], 1))).xyz;

       float t, u, v;

        if (IntersectTriangle(ray, v0, v1, v2, t, u, v))
        {
            if (t > 0 && t < bestHit.rayHitDistance)
            {
                bestHit.rayHitDistance = t;
                bestHit.rayHitPosition = ray.raySource + t * ray.rayDirection;
                bestHit.rayHitNormal = normalize(cross(v1 - v0, v2 - v0));

                bestHit.viewDirection = normalize(_WorldSpaceCameraPos - _Objects[index].Position.rgb);
                bestHit.lightDirection = _DirectionalLightDirection;

                bestHit.rayHitAlbedo = _Objects[index].Albedo;
                bestHit.rayHitEmission = _Objects[index].Emission;
                bestHit.rayHitSmoothness = _Objects[index].Smoothness;
                bestHit.rayHitMetallic = _Objects[index].Metallic;
                bestHit.rayHitAnisotropy = _Objects[index].Anisotropy;

                bestHit.hitRenderType = _Objects[index].RenderType;
            }
        }
    }
}

void IntersectGroundPlane(CameraRay ray, inout CameraRayHit bestHit)
{
    float t = -ray.raySource.y / ray.rayDirection.y;
    if (t > 0 && t < bestHit.rayHitDistance)
    {
        bestHit.rayHitDistance = t;
        bestHit.rayHitPosition = ray.raySource + t * ray.rayDirection;
        bestHit.rayHitNormal = float3(0.0f, 1.0f, 0.0f);

        bestHit.viewDirection = normalize(_WorldSpaceCameraPos - bestHit.rayHitPosition);
        bestHit.lightDirection = _DirectionalLightDirection;

        bestHit.rayHitAlbedo = float4(0.6, 0.6, 0.6,1);
        bestHit.rayHitEmission = float4(0, 0, 0, 0);
        bestHit.rayHitSmoothness = 0.6;
        bestHit.rayHitMetallic = 0.6;
        bestHit.rayHitAnisotropy = 0;

        bestHit.hitRenderType = 0;
    }
}

void IntersectSphere(int index, CameraRay ray, inout CameraRayHit bestHit, float4 sphere)
{
    float3 d = ray.raySource - sphere.xyz;
    float p1 = -dot(ray.rayDirection, d);
    float p2sqr = p1 * p1 - dot(d, d) + sphere.w * sphere.w;
    if (p2sqr < 0)
        return;
    float p2 = sqrt(p2sqr);
    float t = p1 - p2 > 0 ? p1 - p2 : p1 + p2;
    if (t > 0 && t < bestHit.rayHitDistance)
    {
        bestHit.rayHitDistance = t;
        bestHit.rayHitPosition = ray.raySource + t * ray.rayDirection;
        bestHit.rayHitNormal = normalize(bestHit.rayHitPosition - sphere.xyz);

        bestHit.viewDirection = normalize(_WorldSpaceCameraPos - _Objects[index].Position.rgb);
        bestHit.lightDirection = _DirectionalLightDirection;

        bestHit.rayHitAlbedo = _Objects[index].Albedo;
        bestHit.rayHitEmission = _Objects[index].Emission;
        bestHit.rayHitSmoothness = _Objects[index].Smoothness;
        bestHit.rayHitMetallic = _Objects[index].Metallic;
        bestHit.rayHitAnisotropy = _Objects[index].Anisotropy;

        bestHit.hitRenderType = _Objects[index].RenderType;
    }
}
// TRACE RAY //
CameraRayHit Trace(CameraRay ray)
{
    CameraRayHit bestHit = CreateRayHit();
    //IntersectGroundPlane(ray, bestHit);

    for (int i = 0; i < _SceneObjectsCount; i++) {
        //if(_Objects[i].ObjectMesh == 0)
        IntersectMeshObject(i, ray, bestHit);
     //if (_Objects[i].ObjectMesh == 1)
     //IntersectSphere(0, ray, bestHit,float4(_Objects[0].Position.xyz,0.5f));
    }
    return bestHit;
}

float2 _Pixel;
float _Seed;
float rand()
{
    float result = frac(sin(_Seed / 100.0f * dot(_Pixel, float2(12.9898f, 78.233f))) * 43758.5453f);
    _Seed += 1.0f;
    return result;
}

float3x3 GetTangentSpace(float3 normal)
{
    float3 helper = float3(1, 0, 0);
    if (abs(normal.x) > 0.99f)
        helper = float3(0, 0, 1);

    float3 tangent = normalize(cross(normal, helper));
    float3 binormal = normalize(cross(normal, tangent));
    return float3x3(tangent, binormal, normal);
}
//http://corysimon.github.io/articles/uniformdistn-on-sphere/
float3 SampleHemisphere(float3 normal, float alpha)
{
    float cosTheta = pow(rand(), 1.0f / (alpha + 1.0f));
    float sinTheta = sqrt(1.0f - cosTheta * cosTheta);
    float phi = 2 * PI * rand();
    float3 tangentSpaceDir = float3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);

    return mul(tangentSpaceDir, GetTangentSpace(normal));
}

float sdot(float3 x, float3 y, float f = 1.0f) { return saturate(dot(x, y) * f)/PI; }
float energy(float3 color) { return dot(color, 1.0f / 3.0f); }

float SmoothnessToAlpha(float s) { return pow(1000.0f, s * s); }
float oneMinusReflectivity(float metallic) { return 1.0 - metallic * (1.0 - 0.04); }

float PerceptualRoughnessToRoughness(float perceptualRoughness) { return perceptualRoughness * perceptualRoughness; }
float RoughnessToPerceptualRoughness(float roughness) { return sqrt(roughness); }
float RoughnessToPerceptualSmoothness(float roughness) { return 1.0 - sqrt(roughness); }
float PerceptualSmoothnessToRoughness(float perceptualSmoothness) { return (1.0 - perceptualSmoothness) * (1.0 - perceptualSmoothness); }
float PerceptualSmoothnessToPerceptualRoughness(float perceptualSmoothness) { return (1.0 - perceptualSmoothness); }

float3 ShiftTangent(float3 Tangent, float3 Normal, float Shift) { return normalize((Tangent + Shift) * Normal); }

float GGX(CameraRayHit hit, float roughness) {
    float3 h = normalize(hit.lightDirection + hit.viewDirection);
    float NoH = dot(hit.rayHitNormal, h);
    float3 NxH = cross(hit.rayHitNormal, h);
    float a = NoH * roughness;
    float k = roughness / (dot(NxH, NxH) + a * a);
    float d = k * k * (1.0 / PI);
    return saturate(d);
}

float Anisotropy(CameraRayHit hit,float roughness) {
    float at = max(roughness * (1.0 + hit.rayHitAnisotropy), 0.005);
    float ab = max(roughness * (1.0 - hit.rayHitAnisotropy), 0.005);

    float3 h = normalize(hit.lightDirection + hit.viewDirection);
    float NoH = sqrt(1 - dot(normalize(hit.rayHitNormal), h) * dot(normalize(hit.rayHitNormal), h));

    float ToH = dot(ShiftTangent(normalize(GetTangentSpace(hit.rayHitNormal)[0]), normalize(hit.rayHitNormal), 0.1), h);

    float3 b = normalize(cross(normalize(hit.rayHitNormal), GetTangentSpace(hit.rayHitNormal)[0]));

    float BoH = dot(b, h);
    float a2 = at * ab;
    float3 v = float3(ab * ToH, at * BoH, a2 * NoH);
    float v2 = dot(v, v);
    float w2 = a2 / v2;
    return a2 * w2 * w2 * (1.0 / PI);
}

float FresnelBRDF(CameraRayHit hit) {
    float NoV = dot(hit.rayHitNormal, hit.viewDirection);
    float f = pow(1.0 - NoV, 4.0);
    return f * 0.5 + NoV * (1.0 - f) * hit.rayHitMetallic;
}

float FresnelTransmissionBRDF(float f0, float f90, float u)
{
    float x = 1.0 - u;
    float x2 = x * x;
    float x5 = x * x2 * x2;
    return (1.0 - f90 * x5) - f0 * (1.0 - x5);
}

float disneyDiffuse(float NoV, float NoL, float LoH, float roughness)
{
    float  energyBias = lerp(0, 0.7, roughness);
    float  energyFactor = lerp(1.0, 1.0 / 1.51, roughness);
    float  fd90 = energyBias + 1.0 * LoH * LoH * roughness;
    float f0 = 1.0f;
    float lightScatter = FresnelTransmissionBRDF(f0, fd90, NoL);
    float viewScatter = FresnelTransmissionBRDF(f0, fd90, NoV);
    return  lightScatter * viewScatter * energyFactor;
}

float FresnelBRDF(float f0, float u)
{
    return f0 + (1 - f0) * pow(1 - u, 5);
}

float3 MainShadeFunction(inout CameraRay ray, CameraRayHit hit)
{
    if (hit.rayHitDistance < 1.#INF)
    {

        float3 Albedo = hit.rayHitAlbedo * oneMinusReflectivity(hit.rayHitMetallic);
        float3 Specular = lerp(0.04f, hit.rayHitAlbedo, hit.rayHitMetallic);
        float3 Emission = hit.rayHitEmission;

        hit.rayHitAlbedo = Albedo;

        float3 DiffColor = float3(0,0,0);

        float perceptualRoughness = PerceptualSmoothnessToPerceptualRoughness(hit.rayHitSmoothness);
        float roughness = hit.rayHitSmoothness;// PerceptualRoughnessToRoughness(perceptualRoughness);

        float3 h = normalize(hit.lightDirection + hit.viewDirection);
        float LoH = dot(hit.lightDirection, h);
        float LoV = dot(hit.lightDirection, hit.viewDirection);
        float NoL = dot(hit.rayHitNormal, _DirectionalLight);
        float NoH = dot(hit.rayHitNormal, h);

        float specChance = energy(hit.rayHitSmoothness);
        float diffChance = energy(hit.rayHitAlbedo);
        float sum = specChance + diffChance;
        specChance /= sum;
        diffChance /= sum;
        float roulette = rand();

        float alpha = SmoothnessToAlpha(roughness);

        if (roulette < specChance)
        {
            ray.raySource = hit.rayHitPosition + hit.rayHitNormal * 0.001f;
            hit.rayHitPosition = ray.raySource;
            hit.viewDirection = normalize(_WorldSpaceCameraPos - hit.rayHitPosition);

            ray.rayDirection = SampleHemisphere(reflect(ray.rayDirection, hit.rayHitNormal), alpha);
            float f = (alpha + 2) / (alpha + 1);

            float f0 = pow((1) / (1 + 2), 2);
            float F = FresnelBRDF(f0, LoH);
            F = 1;
            if (hit.hitRenderType == 2)
                Specular = (1 / specChance) * Anisotropy(hit, roughness) * F * Specular * f * sdot(hit.rayHitNormal, ray.rayDirection);
            else
                Specular = (1 / specChance) * GGX(hit, roughness) * F * Specular * f * sdot(hit.rayHitNormal, ray.rayDirection);
        }
        else
        {
            ray.raySource = hit.rayHitPosition + hit.rayHitNormal * 0.001f;
            hit.rayHitPosition = ray.raySource;
            hit.viewDirection = normalize(_WorldSpaceCameraPos - hit.rayHitPosition);

            ray.rayDirection = SampleHemisphere(hit.rayHitNormal, 1.0f);
            DiffColor = (1/ diffChance) * (2 * hit.rayHitAlbedo * sdot(hit.rayHitNormal, ray.rayDirection));
        }

        if (hit.hitRenderType == 2)
        ray.rayColor *= Specular + DiffColor * disneyDiffuse(dot(hit.rayHitNormal, hit.viewDirection), NoL, LoH, roughness / PI) + Emission;
        else
        ray.rayColor *= pow(DiffColor,2.2) + Specular + Emission;
        //ray.rayColor = hit.rayHitAlbedo * sdot(hit.rayHitNormal, ray.rayDirection) + Emission + Specular;

        return 0;
    }
    else
    {
        ray.rayColor = 0.0f;

        float theta = acos(ray.rayDirection.y) / -PI;
        float phi = atan2(ray.rayDirection.x, -ray.rayDirection.z) / -PI * 0.5f;
        return _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(phi, theta), 0).xyz;
    }
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    int width, height;
    Result.GetDimensions(width, height);
    float2 uv = float2((id.xy + float2(0.5f, 0.5f)) / float2(width, height) * 2.0f - 1.0f);
    _Pixel = id.xy;
    CameraRay cemaraRay = CreateCameraRay(uv);
    float3 result = float3(0, 0, 0);

    for (int i = 0; i < _rayMaxHits; i++)
    {
        CameraRayHit hit = Trace(cemaraRay);
        result += cemaraRay.rayColor * MainShadeFunction(cemaraRay, hit);

        if (length(cemaraRay.rayColor) <= 0)
            break;
    }

    Result[id.xy] = float4(result, 1);
}
